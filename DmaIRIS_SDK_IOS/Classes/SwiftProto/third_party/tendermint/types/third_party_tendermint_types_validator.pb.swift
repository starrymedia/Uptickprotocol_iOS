// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tendermint/types/validator.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Tendermint_Types_ValidatorSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var validators: [Tendermint_Types_Validator] {
    get {return _storage._validators}
    set {_uniqueStorage()._validators = newValue}
  }

  var proposer: Tendermint_Types_Validator {
    get {return _storage._proposer ?? Tendermint_Types_Validator()}
    set {_uniqueStorage()._proposer = newValue}
  }
  /// Returns true if `proposer` has been explicitly set.
  var hasProposer: Bool {return _storage._proposer != nil}
  /// Clears the value of `proposer`. Subsequent reads from it will return its default value.
  mutating func clearProposer() {_uniqueStorage()._proposer = nil}

  var totalVotingPower: Int64 {
    get {return _storage._totalVotingPower}
    set {_uniqueStorage()._totalVotingPower = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Tendermint_Types_Validator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: Data {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  var pubKey: Tendermint_Crypto_PublicKey {
    get {return _storage._pubKey ?? Tendermint_Crypto_PublicKey()}
    set {_uniqueStorage()._pubKey = newValue}
  }
  /// Returns true if `pubKey` has been explicitly set.
  var hasPubKey: Bool {return _storage._pubKey != nil}
  /// Clears the value of `pubKey`. Subsequent reads from it will return its default value.
  mutating func clearPubKey() {_uniqueStorage()._pubKey = nil}

  var votingPower: Int64 {
    get {return _storage._votingPower}
    set {_uniqueStorage()._votingPower = newValue}
  }

  var proposerPriority: Int64 {
    get {return _storage._proposerPriority}
    set {_uniqueStorage()._proposerPriority = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Tendermint_Types_SimpleValidator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pubKey: Tendermint_Crypto_PublicKey {
    get {return _storage._pubKey ?? Tendermint_Crypto_PublicKey()}
    set {_uniqueStorage()._pubKey = newValue}
  }
  /// Returns true if `pubKey` has been explicitly set.
  var hasPubKey: Bool {return _storage._pubKey != nil}
  /// Clears the value of `pubKey`. Subsequent reads from it will return its default value.
  mutating func clearPubKey() {_uniqueStorage()._pubKey = nil}

  var votingPower: Int64 {
    get {return _storage._votingPower}
    set {_uniqueStorage()._votingPower = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tendermint.types"

extension Tendermint_Types_ValidatorSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatorSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validators"),
    2: .same(proto: "proposer"),
    3: .standard(proto: "total_voting_power"),
  ]

  fileprivate class _StorageClass {
    var _validators: [Tendermint_Types_Validator] = []
    var _proposer: Tendermint_Types_Validator? = nil
    var _totalVotingPower: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _validators = source._validators
      _proposer = source._proposer
      _totalVotingPower = source._totalVotingPower
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._validators)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._proposer)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._totalVotingPower)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._validators.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._validators, fieldNumber: 1)
      }
      if let v = _storage._proposer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._totalVotingPower != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalVotingPower, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Types_ValidatorSet, rhs: Tendermint_Types_ValidatorSet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._validators != rhs_storage._validators {return false}
        if _storage._proposer != rhs_storage._proposer {return false}
        if _storage._totalVotingPower != rhs_storage._totalVotingPower {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Types_Validator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Validator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "pub_key"),
    3: .standard(proto: "voting_power"),
    4: .standard(proto: "proposer_priority"),
  ]

  fileprivate class _StorageClass {
    var _address: Data = SwiftProtobuf.Internal.emptyData
    var _pubKey: Tendermint_Crypto_PublicKey? = nil
    var _votingPower: Int64 = 0
    var _proposerPriority: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _pubKey = source._pubKey
      _votingPower = source._votingPower
      _proposerPriority = source._proposerPriority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._address)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._pubKey)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._votingPower)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._proposerPriority)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._address, fieldNumber: 1)
      }
      if let v = _storage._pubKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._votingPower != 0 {
        try visitor.visitSingularInt64Field(value: _storage._votingPower, fieldNumber: 3)
      }
      if _storage._proposerPriority != 0 {
        try visitor.visitSingularInt64Field(value: _storage._proposerPriority, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Types_Validator, rhs: Tendermint_Types_Validator) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._pubKey != rhs_storage._pubKey {return false}
        if _storage._votingPower != rhs_storage._votingPower {return false}
        if _storage._proposerPriority != rhs_storage._proposerPriority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Types_SimpleValidator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimpleValidator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .standard(proto: "voting_power"),
  ]

  fileprivate class _StorageClass {
    var _pubKey: Tendermint_Crypto_PublicKey? = nil
    var _votingPower: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pubKey = source._pubKey
      _votingPower = source._votingPower
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._pubKey)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._votingPower)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._pubKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._votingPower != 0 {
        try visitor.visitSingularInt64Field(value: _storage._votingPower, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Types_SimpleValidator, rhs: Tendermint_Types_SimpleValidator) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pubKey != rhs_storage._pubKey {return false}
        if _storage._votingPower != rhs_storage._votingPower {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
