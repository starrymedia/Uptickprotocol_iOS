// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cosmos/tx/v1beta1/tx.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Tx is the standard type used for broadcasting transactions.
struct Cosmos_Tx_V1beta1_Tx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// body is the processable content of the transaction
  var body: Cosmos_Tx_V1beta1_TxBody {
    get {return _storage._body ?? Cosmos_Tx_V1beta1_TxBody()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {_uniqueStorage()._body = nil}

  /// auth_info is the authorization related content of the transaction,
  ///
  /// specifically signers, signer modes and fee
  var authInfo: Cosmos_Tx_V1beta1_AuthInfo {
    get {return _storage._authInfo ?? Cosmos_Tx_V1beta1_AuthInfo()}
    set {_uniqueStorage()._authInfo = newValue}
  }
  /// Returns true if `authInfo` has been explicitly set.
  var hasAuthInfo: Bool {return _storage._authInfo != nil}
  /// Clears the value of `authInfo`. Subsequent reads from it will return its default value.
  mutating func clearAuthInfo() {_uniqueStorage()._authInfo = nil}

  /// signatures is a list of signatures that matches the length and order of
  ///
  /// AuthInfo's signer_infos to allow connecting signature meta information like
  ///
  /// public key and signing mode by position.
  var signatures: [Data] {
    get {return _storage._signatures}
    set {_uniqueStorage()._signatures = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TxRaw is a variant of Tx that pins the signer's exact binary representation
///
/// of body and auth_info. This is used for signing, broadcasting and
///
/// verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and
///
/// the hash `sha256(serialize(tx: TxRaw))` becomes the "txhash", commonly used
///
/// as the transaction ID.
struct Cosmos_Tx_V1beta1_TxRaw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// body_bytes is a protobuf serialization of a TxBody that matches the
  ///
  /// representation in SignDoc.
  var bodyBytes: Data = SwiftProtobuf.Internal.emptyData

  /// auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
  ///
  /// representation in SignDoc.
  var authInfoBytes: Data = SwiftProtobuf.Internal.emptyData

  /// signatures is a list of signatures that matches the length and order of
  ///
  /// AuthInfo's signer_infos to allow connecting signature meta information like
  ///
  /// public key and signing mode by position.
  var signatures: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SignDoc is the type used for generating sign bytes for SIGN_MODE_DIRECT.
struct Cosmos_Tx_V1beta1_SignDoc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// body_bytes is protobuf serialization of a TxBody that matches the
  ///
  /// representation in TxRaw.
  var bodyBytes: Data = SwiftProtobuf.Internal.emptyData

  /// auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
  ///
  /// representation in TxRaw.
  var authInfoBytes: Data = SwiftProtobuf.Internal.emptyData

  /// chain_id is the unique identifier of the chain this transaction targets.
  ///
  /// It prevents signed transactions from being used on another chain by an
  ///
  /// attacker
  var chainID: String = String()

  /// account_number is the account number of the account in state
  var accountNumber: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TxBody is the body of a transaction that all signers sign over.
struct Cosmos_Tx_V1beta1_TxBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// messages is a list of messages to be executed. The required signers of
  ///
  /// those messages define the number and order of elements in AuthInfo's
  ///
  /// signer_infos and Tx's signatures. Each required signer address is added to
  ///
  /// the list only the first time it occurs.
  ///
  ///
  ///
  /// By convention, the first required signer (usually from the first message)
  ///
  /// is referred to as the primary signer and pays the fee for the whole
  ///
  /// transaction.
  var messages: [SwiftProtobuf.Google_Protobuf_Any] = []

  /// memo is any arbitrary memo to be added to the transaction
  var memo: String = String()

  /// timeout is the block height after which this transaction will not
  ///
  /// be processed by the chain
  var timeoutHeight: UInt64 = 0

  /// extension_options are arbitrary options that can be added by chains
  ///
  /// when the default options are not sufficient. If any of these are present
  ///
  /// and can't be handled, the transaction will be rejected
  var extensionOptions: [SwiftProtobuf.Google_Protobuf_Any] = []

  /// extension_options are arbitrary options that can be added by chains
  ///
  /// when the default options are not sufficient. If any of these are present
  ///
  /// and can't be handled, they will be ignored
  var nonCriticalExtensionOptions: [SwiftProtobuf.Google_Protobuf_Any] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AuthInfo describes the fee and signer modes that are used to sign a
///
/// transaction.
struct Cosmos_Tx_V1beta1_AuthInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// signer_infos defines the signing modes for the required signers. The number
  ///
  /// and order of elements must match the required signers from TxBody's
  ///
  /// messages. The first element is the primary signer and the one which pays
  ///
  /// the fee.
  var signerInfos: [Cosmos_Tx_V1beta1_SignerInfo] {
    get {return _storage._signerInfos}
    set {_uniqueStorage()._signerInfos = newValue}
  }

  /// Fee is the fee and gas limit for the transaction. The first signer is the
  ///
  /// primary signer and the one which pays the fee. The fee can be calculated
  ///
  /// based on the cost of evaluating the body and doing signature verification
  ///
  /// of the signers. This can be estimated via simulation.
  var fee: Cosmos_Tx_V1beta1_Fee {
    get {return _storage._fee ?? Cosmos_Tx_V1beta1_Fee()}
    set {_uniqueStorage()._fee = newValue}
  }
  /// Returns true if `fee` has been explicitly set.
  var hasFee: Bool {return _storage._fee != nil}
  /// Clears the value of `fee`. Subsequent reads from it will return its default value.
  mutating func clearFee() {_uniqueStorage()._fee = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SignerInfo describes the public key and signing mode of a single top-level
///
/// signer.
struct Cosmos_Tx_V1beta1_SignerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// public_key is the public key of the signer. It is optional for accounts
  ///
  /// that already exist in state. If unset, the verifier can use the required \
  ///
  /// signer address for this position and lookup the public key.
  var publicKey: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._publicKey ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return _storage._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {_uniqueStorage()._publicKey = nil}

  /// mode_info describes the signing mode of the signer and is a nested
  ///
  /// structure to support nested multisig pubkey's
  var modeInfo: Cosmos_Tx_V1beta1_ModeInfo {
    get {return _storage._modeInfo ?? Cosmos_Tx_V1beta1_ModeInfo()}
    set {_uniqueStorage()._modeInfo = newValue}
  }
  /// Returns true if `modeInfo` has been explicitly set.
  var hasModeInfo: Bool {return _storage._modeInfo != nil}
  /// Clears the value of `modeInfo`. Subsequent reads from it will return its default value.
  mutating func clearModeInfo() {_uniqueStorage()._modeInfo = nil}

  /// sequence is the sequence of the account, which describes the
  ///
  /// number of committed transactions signed by a given address. It is used to
  ///
  /// prevent replay attacks.
  var sequence: UInt64 {
    get {return _storage._sequence}
    set {_uniqueStorage()._sequence = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ModeInfo describes the signing mode of a single or nested multisig signer.
struct Cosmos_Tx_V1beta1_ModeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// sum is the oneof that specifies whether this represents a single or nested
  ///
  /// multisig signer
  var sum: OneOf_Sum? {
    get {return _storage._sum}
    set {_uniqueStorage()._sum = newValue}
  }

  /// single represents a single signer
  var single: Cosmos_Tx_V1beta1_ModeInfo.Single {
    get {
      if case .single(let v)? = _storage._sum {return v}
      return Cosmos_Tx_V1beta1_ModeInfo.Single()
    }
    set {_uniqueStorage()._sum = .single(newValue)}
  }

  /// multi represents a nested multisig signer
  var multi: Cosmos_Tx_V1beta1_ModeInfo.Multi {
    get {
      if case .multi(let v)? = _storage._sum {return v}
      return Cosmos_Tx_V1beta1_ModeInfo.Multi()
    }
    set {_uniqueStorage()._sum = .multi(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// sum is the oneof that specifies whether this represents a single or nested
  ///
  /// multisig signer
  enum OneOf_Sum: Equatable {
    /// single represents a single signer
    case single(Cosmos_Tx_V1beta1_ModeInfo.Single)
    /// multi represents a nested multisig signer
    case multi(Cosmos_Tx_V1beta1_ModeInfo.Multi)

  #if !swift(>=4.1)
    static func ==(lhs: Cosmos_Tx_V1beta1_ModeInfo.OneOf_Sum, rhs: Cosmos_Tx_V1beta1_ModeInfo.OneOf_Sum) -> Bool {
      switch (lhs, rhs) {
      case (.single(let l), .single(let r)): return l == r
      case (.multi(let l), .multi(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Single is the mode info for a single signer. It is structured as a message
  ///
  /// to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
  ///
  /// future
  struct Single {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// mode is the signing mode of the single signer
    var mode: Cosmos_Tx_Signing_V1beta1_SignMode = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Multi is the mode info for a multisig public key
  struct Multi {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// bitarray specifies which keys within the multisig are signing
    var bitarray: Cosmos_Crypto_Multisig_V1beta1_CompactBitArray {
      get {return _storage._bitarray ?? Cosmos_Crypto_Multisig_V1beta1_CompactBitArray()}
      set {_uniqueStorage()._bitarray = newValue}
    }
    /// Returns true if `bitarray` has been explicitly set.
    var hasBitarray: Bool {return _storage._bitarray != nil}
    /// Clears the value of `bitarray`. Subsequent reads from it will return its default value.
    mutating func clearBitarray() {_uniqueStorage()._bitarray = nil}

    /// mode_infos is the corresponding modes of the signers of the multisig
    ///
    /// which could include nested multisig public keys
    var modeInfos: [Cosmos_Tx_V1beta1_ModeInfo] {
      get {return _storage._modeInfos}
      set {_uniqueStorage()._modeInfos = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Fee includes the amount of coins paid in fees and the maximum
///
/// gas to be used by the transaction. The ratio yields an effective "gasprice",
///
/// which must be above some miminum to be accepted into the mempool.
struct Cosmos_Tx_V1beta1_Fee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// amount is the amount of coins to be paid as a fee
  var amount: [Cosmos_Base_V1beta1_Coin] = []

  /// gas_limit is the maximum gas that can be used in transaction processing
  ///
  /// before an out of gas error occurs
  var gasLimit: UInt64 = 0

  /// if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
  ///
  /// the payer must be a tx signer (and thus have signed this field in AuthInfo).
  ///
  /// setting this field does *not* change the ordering of required signers for the transaction.
  var payer: String = String()

  /// if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
  ///
  /// to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
  ///
  /// not support fee grants, this will fail
  var granter: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cosmos.tx.v1beta1"

extension Cosmos_Tx_V1beta1_Tx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .standard(proto: "auth_info"),
    3: .same(proto: "signatures"),
  ]

  fileprivate class _StorageClass {
    var _body: Cosmos_Tx_V1beta1_TxBody? = nil
    var _authInfo: Cosmos_Tx_V1beta1_AuthInfo? = nil
    var _signatures: [Data] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _body = source._body
      _authInfo = source._authInfo
      _signatures = source._signatures
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._body)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._authInfo)
        case 3: try decoder.decodeRepeatedBytesField(value: &_storage._signatures)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._authInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._signatures.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._signatures, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_Tx, rhs: Cosmos_Tx_V1beta1_Tx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._body != rhs_storage._body {return false}
        if _storage._authInfo != rhs_storage._authInfo {return false}
        if _storage._signatures != rhs_storage._signatures {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_TxRaw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxRaw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "body_bytes"),
    2: .standard(proto: "auth_info_bytes"),
    3: .same(proto: "signatures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.bodyBytes)
      case 2: try decoder.decodeSingularBytesField(value: &self.authInfoBytes)
      case 3: try decoder.decodeRepeatedBytesField(value: &self.signatures)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bodyBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.bodyBytes, fieldNumber: 1)
    }
    if !self.authInfoBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.authInfoBytes, fieldNumber: 2)
    }
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.signatures, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_TxRaw, rhs: Cosmos_Tx_V1beta1_TxRaw) -> Bool {
    if lhs.bodyBytes != rhs.bodyBytes {return false}
    if lhs.authInfoBytes != rhs.authInfoBytes {return false}
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_SignDoc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignDoc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "body_bytes"),
    2: .standard(proto: "auth_info_bytes"),
    3: .standard(proto: "chain_id"),
    4: .standard(proto: "account_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.bodyBytes)
      case 2: try decoder.decodeSingularBytesField(value: &self.authInfoBytes)
      case 3: try decoder.decodeSingularStringField(value: &self.chainID)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.accountNumber)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bodyBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.bodyBytes, fieldNumber: 1)
    }
    if !self.authInfoBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.authInfoBytes, fieldNumber: 2)
    }
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 3)
    }
    if self.accountNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.accountNumber, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_SignDoc, rhs: Cosmos_Tx_V1beta1_SignDoc) -> Bool {
    if lhs.bodyBytes != rhs.bodyBytes {return false}
    if lhs.authInfoBytes != rhs.authInfoBytes {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.accountNumber != rhs.accountNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_TxBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .same(proto: "memo"),
    3: .standard(proto: "timeout_height"),
    1023: .standard(proto: "extension_options"),
    2047: .standard(proto: "non_critical_extension_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.messages)
      case 2: try decoder.decodeSingularStringField(value: &self.memo)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.timeoutHeight)
      case 1023: try decoder.decodeRepeatedMessageField(value: &self.extensionOptions)
      case 2047: try decoder.decodeRepeatedMessageField(value: &self.nonCriticalExtensionOptions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    if !self.memo.isEmpty {
      try visitor.visitSingularStringField(value: self.memo, fieldNumber: 2)
    }
    if self.timeoutHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.timeoutHeight, fieldNumber: 3)
    }
    if !self.extensionOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.extensionOptions, fieldNumber: 1023)
    }
    if !self.nonCriticalExtensionOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nonCriticalExtensionOptions, fieldNumber: 2047)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_TxBody, rhs: Cosmos_Tx_V1beta1_TxBody) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.memo != rhs.memo {return false}
    if lhs.timeoutHeight != rhs.timeoutHeight {return false}
    if lhs.extensionOptions != rhs.extensionOptions {return false}
    if lhs.nonCriticalExtensionOptions != rhs.nonCriticalExtensionOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_AuthInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signer_infos"),
    2: .same(proto: "fee"),
  ]

  fileprivate class _StorageClass {
    var _signerInfos: [Cosmos_Tx_V1beta1_SignerInfo] = []
    var _fee: Cosmos_Tx_V1beta1_Fee? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _signerInfos = source._signerInfos
      _fee = source._fee
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._signerInfos)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._fee)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._signerInfos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._signerInfos, fieldNumber: 1)
      }
      if let v = _storage._fee {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_AuthInfo, rhs: Cosmos_Tx_V1beta1_AuthInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._signerInfos != rhs_storage._signerInfos {return false}
        if _storage._fee != rhs_storage._fee {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_SignerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "mode_info"),
    3: .same(proto: "sequence"),
  ]

  fileprivate class _StorageClass {
    var _publicKey: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _modeInfo: Cosmos_Tx_V1beta1_ModeInfo? = nil
    var _sequence: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _publicKey = source._publicKey
      _modeInfo = source._modeInfo
      _sequence = source._sequence
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._publicKey)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._modeInfo)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._sequence)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._publicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._modeInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._sequence != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._sequence, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_SignerInfo, rhs: Cosmos_Tx_V1beta1_SignerInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._modeInfo != rhs_storage._modeInfo {return false}
        if _storage._sequence != rhs_storage._sequence {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_ModeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModeInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "single"),
    2: .same(proto: "multi"),
  ]

  fileprivate class _StorageClass {
    var _sum: Cosmos_Tx_V1beta1_ModeInfo.OneOf_Sum?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sum = source._sum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Cosmos_Tx_V1beta1_ModeInfo.Single?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .single(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .single(v)}
        case 2:
          var v: Cosmos_Tx_V1beta1_ModeInfo.Multi?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .multi(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .multi(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._sum {
      case .single(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .multi(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_ModeInfo, rhs: Cosmos_Tx_V1beta1_ModeInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sum != rhs_storage._sum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_ModeInfo.Single: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Cosmos_Tx_V1beta1_ModeInfo.protoMessageName + ".Single"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.mode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .unspecified {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_ModeInfo.Single, rhs: Cosmos_Tx_V1beta1_ModeInfo.Single) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_ModeInfo.Multi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Cosmos_Tx_V1beta1_ModeInfo.protoMessageName + ".Multi"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bitarray"),
    2: .standard(proto: "mode_infos"),
  ]

  fileprivate class _StorageClass {
    var _bitarray: Cosmos_Crypto_Multisig_V1beta1_CompactBitArray? = nil
    var _modeInfos: [Cosmos_Tx_V1beta1_ModeInfo] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _bitarray = source._bitarray
      _modeInfos = source._modeInfos
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._bitarray)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._modeInfos)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._bitarray {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._modeInfos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._modeInfos, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_ModeInfo.Multi, rhs: Cosmos_Tx_V1beta1_ModeInfo.Multi) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._bitarray != rhs_storage._bitarray {return false}
        if _storage._modeInfos != rhs_storage._modeInfos {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_Fee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Fee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .standard(proto: "gas_limit"),
    3: .same(proto: "payer"),
    4: .same(proto: "granter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.amount)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.gasLimit)
      case 3: try decoder.decodeSingularStringField(value: &self.payer)
      case 4: try decoder.decodeSingularStringField(value: &self.granter)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 1)
    }
    if self.gasLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.gasLimit, fieldNumber: 2)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 3)
    }
    if !self.granter.isEmpty {
      try visitor.visitSingularStringField(value: self.granter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_Fee, rhs: Cosmos_Tx_V1beta1_Fee) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.gasLimit != rhs.gasLimit {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.granter != rhs.granter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
